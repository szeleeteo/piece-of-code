<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball in Rotating Hexagon – Realistic Physics</title>
    <style>
        :root {
            --bg: #0b0f14;
            --fg: #e6edf3;
            --accent: #86e1ff;
            --muted: #253040;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 600px at 50% -10%, #101827 10%, var(--bg) 60%);
            color: var(--fg);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            overflow: hidden;
            display: grid;
            grid-template-rows: auto 1fr auto;
        }

        header {
            display: flex;
            align-items: center;
            gap: .8rem;
            padding: 14px 16px;
            backdrop-filter: blur(6px);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.00));
            border-bottom: 1px solid #122031;
        }

        header h1 {
            font-size: 16px;
            font-weight: 600;
            letter-spacing: .2px;
            margin: 0;
            opacity: .9
        }

        .controls {
            margin-left: auto;
            display: flex;
            flex-wrap: wrap;
            gap: .6rem;
            align-items: center
        }

        .pill {
            background: #111a26;
            border: 1px solid #1c2a3e;
            color: var(--fg);
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: .5rem;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.02) inset;
        }

        .pill input[type=range] {
            width: 120px;
            accent-color: var(--accent);
        }

        .pill label {
            opacity: .75
        }

        .btn {
            border: 1px solid #1c2a3e;
            background: #0f1824;
            color: var(--fg);
            padding: 6px 12px;
            border-radius: 10px;
            font-size: 12px;
            cursor: pointer;
            transition: transform .08s ease;
            box-shadow: 0 6px 14px rgba(0, 0, 0, .25);
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0px) scale(.98);
        }

        canvas {
            width: 100vw;
            height: calc(100svh - 120px);
            display: block;
        }

        footer {
            height: 52px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: .5rem;
            color: #94a3b8;
            font-size: 12px;
            border-top: 1px solid #122031;
            background: linear-gradient(0deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.00));
        }

        .key {
            padding: 2px 6px;
            border: 1px solid #223049;
            border-radius: 6px;
            background: #0f1824;
            color: #cbd5e1
        }
    </style>
</head>

<body>
    <header>
        <h1>Ball in Rotating Hexagon · Realistic Gravity & Wall Friction</h1>
        <div class="controls">
            <div class="pill"><label for="grav">Gravity</label><input id="grav" type="range" min="300" max="3000"
                    value="1600" step="50"><span id="gravLabel">1600</span></div>
            <div class="pill"><label for="rest">Restitution</label><input id="rest" type="range" min="0" max="0.95"
                    value="0.72" step="0.01"><span id="restLabel">0.72</span></div>
            <div class="pill"><label for="fric">Friction</label><input id="fric" type="range" min="0" max="0.6"
                    value="0.18" step="0.01"><span id="fricLabel">0.18</span></div>
            <div class="pill"><label for="omega">Spin (deg/s)</label><input id="omega" type="range" min="-120" max="120"
                    value="28" step="1"><span id="omegaLabel">28</span></div>
            <button class="btn" id="reset">Reset</button>
            <button class="btn" id="pause">Pause</button>
        </div>
    </header>

    <canvas id="canvas"></canvas>

    <footer>
        <span>Controls: <span class="key">Space</span> pause · <span class="key">R</span> reset · Drag ball with
            pointer</span>
    </footer>

    <script>
        (function () {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            // --- UI bindings
            const gSlider = document.getElementById('grav');
            const eSlider = document.getElementById('rest');
            const fSlider = document.getElementById('fric');
            const wSlider = document.getElementById('omega');
            const labels = {
                gravLabel: document.getElementById('gravLabel'),
                restLabel: document.getElementById('restLabel'),
                fricLabel: document.getElementById('fricLabel'),
                omegaLabel: document.getElementById('omegaLabel')
            };
            const btnReset = document.getElementById('reset');
            const btnPause = document.getElementById('pause');

            function updateLabels() {
                labels.gravLabel.textContent = (+gSlider.value).toFixed(0);
                labels.restLabel.textContent = (+eSlider.value).toFixed(2);
                labels.fricLabel.textContent = (+fSlider.value).toFixed(2);
                labels.omegaLabel.textContent = (+wSlider.value).toFixed(0);
            }
            updateLabels();
            [gSlider, eSlider, fSlider, wSlider].forEach(el => el.addEventListener('input', updateLabels));

            // --- Canvas sizing
            function resize() {
                const dpr = Math.min(2, window.devicePixelRatio || 1);
                const w = Math.floor(canvas.clientWidth * dpr);
                const h = Math.floor(canvas.clientHeight * dpr);
                if (canvas.width !== w || canvas.height !== h) {
                    canvas.width = w; canvas.height = h;
                }
            }
            window.addEventListener('resize', resize, { passive: true });
            resize();

            // --- World / physics params
            let paused = false;
            const R = 18; // ball radius in px (device pixels)
            let restitution = parseFloat(eSlider.value);
            let friction = parseFloat(fSlider.value); // tangential velocity decay on bounce [0..1]
            let gravity = parseFloat(gSlider.value); // px/s^2 downward
            let omega = parseFloat(wSlider.value) * Math.PI / 180; // rad/s

            eSlider.addEventListener('input', () => { restitution = parseFloat(eSlider.value); });
            fSlider.addEventListener('input', () => { friction = parseFloat(fSlider.value); });
            gSlider.addEventListener('input', () => { gravity = parseFloat(gSlider.value); });
            wSlider.addEventListener('input', () => { omega = parseFloat(wSlider.value) * Math.PI / 180; });

            // Hexagon geometry (regular hexagon centered on screen)
            const hex = {
                center: { x: canvas.width / 2, y: canvas.height / 2 },
                baseRadius: Math.min(canvas.width, canvas.height) * 0.28,
                angle: 0
            };

            // Ball state
            const ball = {
                p: { x: hex.center.x, y: hex.center.y - 40 },
                v: { x: 180, y: 0 },
                dragging: false,
                dragOffset: { x: 0, y: 0 }
            };

            // Inputs: drag to move ball
            let pointerId = null;
            canvas.addEventListener('pointerdown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const dpr = Math.min(2, window.devicePixelRatio || 1);
                const x = (e.clientX - rect.left) * dpr;
                const y = (e.clientY - rect.top) * dpr;
                const dx = x - ball.p.x, dy = y - ball.p.y;
                if (dx * dx + dy * dy <= (R * R) * 1.6) {
                    pointerId = e.pointerId; canvas.setPointerCapture(pointerId);
                    ball.dragging = true; ball.v.x = ball.v.y = 0;
                    ball.dragOffset.x = x - ball.p.x; ball.dragOffset.y = y - ball.p.y;
                }
            });
            canvas.addEventListener('pointermove', (e) => {
                if (!ball.dragging || e.pointerId !== pointerId) return;
                const rect = canvas.getBoundingClientRect();
                const dpr = Math.min(2, window.devicePixelRatio || 1);
                const x = (e.clientX - rect.left) * dpr;
                const y = (e.clientY - rect.top) * dpr;
                ball.p.x = x - ball.dragOffset.x;
                ball.p.y = y - ball.dragOffset.y;
            });
            function endDrag(e) {
                if (e && pointerId !== null && e.pointerId !== pointerId) return;
                ball.dragging = false; if (pointerId !== null) canvas.releasePointerCapture(pointerId); pointerId = null;
            }
            canvas.addEventListener('pointerup', endDrag);
            canvas.addEventListener('pointercancel', endDrag);

            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') { paused = !paused; btnPause.textContent = paused ? 'Resume' : 'Pause'; }
                if (e.key.toLowerCase() === 'r') { reset(); }
            });
            btnPause.addEventListener('click', () => { paused = !paused; btnPause.textContent = paused ? 'Resume' : 'Pause'; });
            btnReset.addEventListener('click', reset);

            function reset() {
                ball.p.x = hex.center.x; ball.p.y = hex.center.y - 40;
                ball.v.x = 180; ball.v.y = 0;
            }

            // Utility
            function rotatePoint(px, py, cx, cy, ang) {
                const s = Math.sin(ang), c = Math.cos(ang);
                const dx = px - cx, dy = py - cy;
                return { x: cx + c * dx - s * dy, y: cy + s * dx + c * dy };
            }

            function hexVertices() {
                const verts = [];
                for (let i = 0; i < 6; i++) {
                    const a0 = i * Math.PI / 3; // base orientation
                    const base = { x: hex.center.x + hex.baseRadius * Math.cos(a0), y: hex.center.y + hex.baseRadius * Math.sin(a0) };
                    verts.push(rotatePoint(base.x, base.y, hex.center.x, hex.center.y, hex.angle));
                }
                return verts;
            }

            function closestPointOnSegment(p, a, b) {
                const abx = b.x - a.x, aby = b.y - a.y;
                const apx = p.x - a.x, apy = p.y - a.y;
                const ab2 = abx * abx + aby * aby;
                let t = (apx * abx + apy * aby) / (ab2 || 1);
                t = Math.max(0, Math.min(1, t));
                return { x: a.x + abx * t, y: a.y + aby * t, t };
            }

            function length(x, y) { return Math.hypot(x, y); }

            // Physics integration (semi-implicit Euler with fixed timestep)
            let last = performance.now();
            const fixedDt = 1 / 120; // seconds
            let acc = 0;

            function step(dt) {
                // update hex rotation
                hex.angle += omega * dt;

                if (ball.dragging) return; // don't integrate while dragging

                // gravity & damping
                ball.v.y += gravity * dt;
                // small air damping for numerical stability
                const air = Math.exp(-dt * 0.6);
                ball.v.x *= air; ball.v.y *= air;

                // integrate position
                ball.p.x += ball.v.x * dt;
                ball.p.y += ball.v.y * dt;

                // collisions with hexagon edges
                const verts = hexVertices();
                for (let i = 0; i < 6; i++) {
                    const a = verts[i];
                    const b = verts[(i + 1) % 6];
                    const cp = closestPointOnSegment(ball.p, a, b);
                    const dx = ball.p.x - cp.x; const dy = ball.p.y - cp.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist < R) {
                        // contact normal from wall toward ball (inward to outward along penetration)
                        let nx, ny;
                        if (dist > 1e-6) { nx = dx / dist; ny = dy / dist; }
                        else {
                            // extremely rare: pick edge inward normal
                            const ex = b.x - a.x, ey = b.y - a.y;
                            const len = Math.hypot(ex, ey) || 1; // inward normal for CCW polygon is left normal
                            nx = -ey / len; ny = ex / len;
                        }

                        // wall velocity at contact point due to rotation
                        const rx = cp.x - hex.center.x, ry = cp.y - hex.center.y;
                        const vwx = -omega * ry; // perp of r scaled by omega
                        const vwy = omega * rx;

                        // relative velocity
                        const rvx = ball.v.x - vwx;
                        const rvy = ball.v.y - vwy;
                        const vn = rvx * nx + rvy * ny; // normal component (toward wall negative if penetrating)

                        if (vn < 0) {
                            // separate: positional correction (project out of wall)
                            const penetration = (R - dist);
                            const slop = 0.5; // allow tiny overlap
                            const corr = Math.max(0, penetration - slop);
                            ball.p.x += nx * corr;
                            ball.p.y += ny * corr;

                            // reflect normal with restitution, apply friction on tangential
                            const tx = -ny, ty = nx; // tangent unit (perpendicular to normal)
                            const vt = rvx * tx + rvy * ty;

                            const vnAfter = -restitution * vn;
                            const vtAfter = vt * Math.max(0, (1 - friction));

                            // new relative velocity
                            const rvx2 = vnAfter * nx + vtAfter * tx;
                            const rvy2 = vnAfter * ny + vtAfter * ty;

                            // convert back to world velocity by adding wall velocity
                            ball.v.x = rvx2 + vwx;
                            ball.v.y = rvy2 + vwy;
                        }
                    }
                }

                // keep ball within canvas bounds gently (visual safety net when window is tiny)
                const margin = 6;
                if (ball.p.x < margin) { ball.p.x = margin; ball.v.x = Math.abs(ball.v.x) * 0.4; }
                if (ball.p.x > canvas.width - margin) { ball.p.x = canvas.width - margin; ball.v.x = -Math.abs(ball.v.x) * 0.4; }
                if (ball.p.y > canvas.height - margin) { ball.p.y = canvas.height - margin; ball.v.y = -Math.abs(ball.v.y) * 0.4; }
                if (ball.p.y < margin) { ball.p.y = margin; ball.v.y = Math.abs(ball.v.y) * 0.2; }
            }

            function render() {
                const dpr = Math.min(2, window.devicePixelRatio || 1);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // subtle vignette
                const g = ctx.createRadialGradient(hex.center.x, hex.center.y, 10, hex.center.x, hex.center.y, Math.max(canvas.width, canvas.height));
                g.addColorStop(0, 'rgba(134,225,255,0.06)');
                g.addColorStop(1, 'rgba(0,0,0,0.0)');
                ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);

                // draw hexagon
                const verts = hexVertices();
                ctx.lineWidth = 3 * dpr;
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath();
                ctx.moveTo(verts[0].x, verts[0].y);
                for (let i = 1; i < 6; i++) ctx.lineTo(verts[i].x, verts[i].y);
                ctx.closePath();
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 16 * dpr;
                ctx.stroke();
                ctx.shadowBlur = 0;

                // floor glow
                ctx.save();
                ctx.translate(ball.p.x, ball.p.y);
                const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, R * 2.8);
                glow.addColorStop(0, 'rgba(134,225,255,.18)');
                glow.addColorStop(1, 'rgba(134,225,255,0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(0, 0, R * 2.8, 0, Math.PI * 2);
                ctx.fill();

                // draw ball
                const ballGrad = ctx.createRadialGradient(-R * 0.4, -R * 0.4, R * 0.25, 0, 0, R);
                ballGrad.addColorStop(0, '#c5f3ff');
                ballGrad.addColorStop(1, '#5fbad1');
                ctx.fillStyle = ballGrad;
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2 * dpr;
                ctx.beginPath(); ctx.arc(0, 0, R, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

                // motion hint
                ctx.beginPath(); ctx.moveTo(-R * 0.3, -R * 0.3); ctx.lineTo(R * 0.2, R * 0.2); ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth = 1.5 * dpr; ctx.stroke();

                ctx.restore();
            }

            // Animation loop with fixed timestep accumulator
            function loop(now) {
                resize();
                hex.center.x = canvas.width / 2; hex.center.y = canvas.height / 2;
                hex.baseRadius = Math.min(canvas.width, canvas.height) * 0.28;

                const dt = Math.min(0.05, (now - last) / 1000); // clamp to avoid spikes
                last = now; if (!paused) { acc += dt; }
                const h = fixedDt;
                let steps = 0, maxSteps = 6; // prevent spiral of death
                while (acc >= h && steps < maxSteps) { step(h); acc -= h; steps++; }
                render();
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        })();
    </script>
</body>

</html>
<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flowing Particle Visualization</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background: #0b0f17;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        // --- PRNG ---
        function mulberry32(a) {
            return function () {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // --- Lightweight 2D Perlin Noise ---
        class Perlin2D {
            constructor(seed = 1337) {
                this.rand = mulberry32(seed >>> 0);
                this.perm = new Uint8Array(512);
                this.grad = new Float32Array(512 * 2);
                const p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = (this.rand() * (i + 1)) | 0;[p[i], p[j]] = [p[j], p[i]];
                }
                for (let i = 0; i < 512; i++) {
                    const v = p[i & 255];
                    this.perm[i] = v;
                    const a = (this.rand() * Math.PI * 2);
                    this.grad[i * 2 + 0] = Math.cos(a);
                    this.grad[i * 2 + 1] = Math.sin(a);
                }
            }
            dot(ix, iy, x, y, gi) { return (x - ix) * this.grad[gi * 2] + (y - iy) * this.grad[gi * 2 + 1]; }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(a, b, t) { return a + (b - a) * t; }
            noise(x, y) {
                const X = Math.floor(x), Y = Math.floor(y);
                const xf = x - X, yf = y - Y;
                const gi00 = this.perm[X + this.perm[Y & 255]];
                const gi10 = this.perm[(X + 1) + this.perm[Y & 255]];
                const gi01 = this.perm[X + this.perm[(Y + 1) & 255]];
                const gi11 = this.perm[(X + 1) + this.perm[(Y + 1) & 255]];
                const n00 = this.dot(X, Y, x, y, gi00);
                const n10 = this.dot(X + 1, Y, x, y, gi10);
                const n01 = this.dot(X, Y + 1, x, y, gi01);
                const n11 = this.dot(X + 1, Y + 1, x, y, gi11);
                const u = this.fade(xf), v = this.fade(yf);
                const nx0 = this.lerp(n00, n10, u);
                const nx1 = this.lerp(n01, n11, u);
                return this.lerp(nx0, nx1, v);
            }
        }

        // --- Setup ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

        const state = {
            seed: (Math.random() * 1e9) | 0,
            particles: 2200,
            speed: 1.2,
            scale: 700,
            flow: 0.004,
            fade: 0.06,
            width: 0.75,
            colorMode: 'velocity',
            t: 0,
            pointer: { x: 0, y: 0, down: false }
        };

        let noise, pts = [], random;

        function resize() {
            const { innerWidth: w, innerHeight: h } = window;
            DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
            canvas.width = Math.floor(w * DPR);
            canvas.height = Math.floor(h * DPR);
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
            ctx.fillStyle = '#0a0e15';
            ctx.fillRect(0, 0, w, h);
        }

        function reseed(newSeed) {
            state.seed = (newSeed == null ? (Math.random() * 1e9) | 0 : newSeed) >>> 0;
            noise = new Perlin2D(state.seed);
            random = mulberry32(state.seed ^ 0xA5A5A5A5);
            initParticles();
        }

        // --- Particles ---
        class Particle {
            constructor(w, h) { this.reset(w, h); }
            reset(w, h) {
                this.x = random() * w;
                this.y = random() * h;
                this.px = this.x; this.py = this.y;
                this.vx = 0; this.vy = 0;
                this.life = 0; this.maxLife = 400 + (random() * 600) | 0;
            }
            step(w, h) {
                const s = state;
                const nx = (this.x / s.scale) + 13.37;
                const ny = (this.y / s.scale) + 42.42;
                const angle = noise.noise(nx, ny + s.t) * Math.PI * 2;
                // base flow direction
                let ax = Math.cos(angle), ay = Math.sin(angle);
                // click-to-attract interaction
                if (s.pointer.down) {
                    const dx = (s.pointer.x - this.x);
                    const dy = (s.pointer.y - this.y);
                    const r2 = dx * dx + dy * dy + 64; // soften singularity
                    const inv = 220 / r2;          // mild force
                    ax += dx * inv; ay += dy * inv;
                }
                // integrate with damping
                this.vx = (this.vx + ax * 0.5) * 0.95;
                this.vy = (this.vy + ay * 0.5) * 0.95;
                this.x += this.vx * s.speed;
                this.y += this.vy * s.speed;
                // wrap + reset previous to avoid streaks
                const margin = 4;
                if (this.x < -margin) { this.x += w + margin * 2; this.px = this.x; }
                if (this.y < -margin) { this.y += h + margin * 2; this.py = this.y; }
                if (this.x > w + margin) { this.x -= w + margin * 2; this.px = this.x; }
                if (this.y > h + margin) { this.y -= h + margin * 2; this.py = this.y; }
                this.life++;
                if (this.life > this.maxLife) this.reset(w, h);
            }
            draw() {
                ctx.beginPath();
                ctx.moveTo(this.px, this.py);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
                this.px = this.x; this.py = this.y;
            }
        }

        function initParticles() {
            const w = canvas.clientWidth, h = canvas.clientHeight;
            pts = new Array(state.particles).fill(0).map(() => new Particle(w, h));
            ctx.fillStyle = '#0a0e15';
            ctx.fillRect(0, 0, w, h);
        }

        function colorFor(p) {
            const ang = Math.atan2(p.vy, p.vx);
            const hue = ((ang / (Math.PI * 2)) * 360 + 360) % 360;
            return `hsl(${hue} 90% 65%)`;
        }

        // --- Animation ---
        let last = 0;
        function frame(ts) {
            if (!last) last = ts;
            const dt = Math.min(32, ts - last) / 1000;
            last = ts;
            state.t += state.flow * dt * 60;
            step();
            draw();
            requestAnimationFrame(frame);
        }

        function step() {
            const w = canvas.clientWidth, h = canvas.clientHeight;
            for (let i = 0; i < pts.length; i++) pts[i].step(w, h);
        }

        function draw() {
            const w = canvas.clientWidth, h = canvas.clientHeight;
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = `rgba(10,14,21,${state.fade})`;
            ctx.fillRect(0, 0, w, h);
            ctx.globalCompositeOperation = 'lighter';
            ctx.lineCap = 'round';
            ctx.lineWidth = state.width;
            for (let i = 0; i < pts.length; i++) {
                ctx.strokeStyle = colorFor(pts[i]);
                pts[i].draw();
            }
        }

        // --- Pointer interactions (click or press-and-hold to attract) ---
        function updatePointer(e) {
            const rect = canvas.getBoundingClientRect();
            state.pointer.x = (e.clientX - rect.left);
            state.pointer.y = (e.clientY - rect.top);
        }
        window.addEventListener('pointerdown', (e) => { state.pointer.down = true; updatePointer(e); });
        window.addEventListener('pointerup', () => { state.pointer.down = false; });
        window.addEventListener('pointermove', updatePointer);

        // Optional: double-click to reseed
        window.addEventListener('dblclick', () => reseed());

        // --- Boot ---
        window.addEventListener('resize', resize);
        resize();
        reseed(state.seed);
        requestAnimationFrame(frame);
    </script>
</body>

</html>